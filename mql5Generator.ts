import type { EAConfig } from './types.ts';

/**
 * Generates the MQL5 file header comment block.
 * @param strategyName - The name of the strategy (e.g., "Grid", "Signal").
 * @param description - A brief description of the EA.
 * @returns A formatted string for the file header.
 */
const generateHeader = (strategyName: string, description: string): string => `
//+------------------------------------------------------------------+
//|                                       Quantum_Bitcoin_EA.mq5 |
//|                      Generated by MQL5 Quantum Generator         |
//|               Strategy: ${strategyName} - See Notice Below                 |
//+------------------------------------------------------------------+
#property copyright "Generated Code"
#property link      "https://github.com/your-repo"
#property version   "1.00"
#property description "${description}"
/*
//+------------------------------------------------------------------+
//|                         IMPORTANT NOTICE                           |
//+------------------------------------------------------------------+
//| This Expert Advisor (EA) was auto-generated by a web application.|
//| It is intended for EDUCATIONAL AND ILLUSTRATIVE purposes only.   |
//|                                                                  |
//| FINANCIAL TRADING INVOLVES SUBSTANTIAL RISK OF LOSS.             |
//| Past performance is not indicative of future results.            |
//|                                                                  |
//| BEFORE USING THIS EA WITH REAL MONEY, YOU MUST:                  |
//| 1. Thoroughly understand all of its input parameters.            |
//| 2. Conduct extensive backtesting in the Strategy Tester.         |
//| 3. Run it on a DEMO account for a significant period to          |
//|    observe its behavior in live market conditions.               |
//|                                                                  |
//| The user of this code assumes full responsibility for any and    |
//| all financial outcomes, including losses. The generator/creator  |
//| of this code is not liable for any financial damages.            |
//+------------------------------------------------------------------+
*/`;

/**
 * Formats a single MQL5 input line for consistent alignment.
 * @param type - The MQL5 data type (e.g., "ulong", "double").
 * @param name - The MQL5 variable name (e.g., "InpMagicNumber").
 * @param value - The value to assign to the input.
 * @param comment - The trailing comment describing the input.
 * @returns A formatted MQL5 input string.
 */
const formatInput = (type: string, name: string, value: any, comment: string): string => {
    const typePadded = type.padEnd(16, ' ');
    const namePadded = name.padEnd(27, ' ');
    return `input ${typePadded} ${namePadded} = ${value};    // ${comment}`;
};

/**
 * Generates the MQL5 input parameters block for the Grid strategy.
 * @param config - The EA configuration object.
 * @returns A formatted string of MQL5 input parameters.
 */
const generateGridInputs = (config: EAConfig): string => {
  const maMethod = config.maType === 'SMA' ? 'MODE_SMA' : 'MODE_EMA';
  const inputs = [
    formatInput('ulong', 'InpMagicNumber', config.magicNumber, 'Unique EA identifier to distinguish its trades from others.'),
    formatInput('double', 'InpInitialRiskPercent', config.initialRiskPercent.toFixed(2), 'Percentage of equity used to calculate the initial lot size.'),
    formatInput('int', 'InpMaxSpread', config.maxSpread, 'Max allowed spread in points; trading is paused if exceeded.'),
    formatInput('int', 'InpGridDistance', config.gridDistance, 'Initial distance in points between grid trades.'),
    formatInput('double', 'InpGridDistanceMultiplier', config.gridDistanceMultiplier.toFixed(2), 'Multiplier to increase distance for subsequent trades (1.0 = fixed).'),
    formatInput('double', 'InpGridMultiplier', config.gridMultiplier.toFixed(2), 'Lot size multiplier for each new grid trade (e.g., Martingale).'),
    formatInput('int', 'InpMaxGridTrades', config.maxGridTrades, 'Maximum number of trades allowed in a single grid series.'),
    formatInput('ENUM_MA_METHOD', 'InpMAMethod', maMethod, 'Method for the trend-filtering Moving Average (SMA/EMA).'),
    formatInput('int', 'InpMAPeriod', config.maPeriod, 'Period for the trend-filtering Moving Average.'),
    formatInput('double', 'InpTakeProfit', config.takeProfit.toFixed(2), 'Aggregate profit in account currency to close the entire grid.'),
    formatInput('double', 'InpTakeProfitMultiplier', config.takeProfitMultiplier.toFixed(2), 'Multiplies TP target as more trades open (1.0 = fixed).'),
    formatInput('double', 'InpStopLoss', config.stopLoss.toFixed(2), 'Aggregate loss as a % of account equity to close the entire grid.'),
    formatInput('bool', 'InpUseTrailingStop', config.useTrailingStop ? 'true' : 'false', 'If true, enables the dynamic trailing stop loss.'),
    formatInput('int', 'InpTrailingStopStart', config.trailingStopStart, 'Profit in points to activate the trailing stop.'),
    formatInput('int', 'InpTrailingStopDistance', config.trailingStopDistance, 'Distance in points the SL will trail behind price.'),
  ];
  return `//--- EA Input Parameters\n${inputs.join('\n')}`;
};

/**
 * Generates the MQL5 input parameters block for the Signal strategy.
 * @param config - The EA configuration object.
 * @returns A formatted string of MQL5 input parameters.
 */
const generateSignalInputs = (config: EAConfig): string => {
    const maMethod = config.signal_maType === 'SMA' ? 'MODE_SMA' : 'MODE_EMA';
    const eaInputs = [
        formatInput('ulong', 'InpMagicNumber', config.magicNumber, 'Unique EA identifier to distinguish its trades from others.'),
        formatInput('int', 'InpMaxSpread', config.maxSpread, 'Max allowed spread in points; trading is paused if exceeded.'),
    ];
    const riskInputs = [
        formatInput('double', 'InpLotSize', config.signal_lotSize.toFixed(2), 'Fixed lot size for every trade.'),
        formatInput('bool', 'InpUseTrailingStop', config.signal_useTrailingStop ? 'true' : 'false', 'If true, enables the dynamic trailing stop loss.'),
        formatInput('int', 'InpTrailingStopStart', config.signal_trailingStopStart, 'Profit in points to activate the trailing stop.'),
        formatInput('int', 'InpTrailingStopDistance', config.signal_trailingStopDistance, 'Distance in points the SL will trail behind price.'),
    ];
    const entryInputs = [
        formatInput('ENUM_MA_METHOD', 'InpMAMethod', maMethod, 'Method for the trend-filtering Moving Average (SMA/EMA).'),
        formatInput('int', 'InpMAPeriod', config.signal_maPeriod, 'Period for the trend-filtering Moving Average.'),
        formatInput('int', 'InpATRPeriod', config.signal_atrPeriod, 'Period for the ATR indicator (used for SL/TP).'),
        formatInput('double', 'InpATRMultiplierSL', config.signal_atrMultiplierSL.toFixed(2), 'Multiplier of ATR value to set the Stop Loss distance.'),
        formatInput('double', 'InpATRMultiplierTP', config.signal_atrMultiplierTP.toFixed(2), 'Multiplier of ATR value to set the Take Profit distance.'),
        formatInput('int', 'InpRSIPeriod', config.signal_rsiPeriod, 'Period for the RSI indicator (used for entry signals).'),
        formatInput('double', 'InpRSIOversold', config.signal_rsiOversold, 'RSI level below which buy signals are considered.'),
        formatInput('double', 'InpRSIOverbought', config.signal_rsiOverbought, 'RSI level above which sell signals are considered.'),
    ];

    return `//--- EA Inputs\n${eaInputs.join('\n')}\n\n//--- Risk Management\n${riskInputs.join('\n')}\n\n//--- Entry Signal\n${entryInputs.join('\n')}`;
};

const generateGridStrategyCode = (config: EAConfig): string => {
  const header = generateHeader('Grid', 'A trend-following grid EA for BTC/USD H1. See the NOTICE in the code.');
  const inputs = generateGridInputs(config);

  const coreLogic = `
#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>

//--- Global Variables & Objects
CTrade         trade;                  // Trade execution object
CPositionInfo  posInfo;                // Position information object
int            ma_handle;              // Handle for the Moving Average indicator

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//| This function is called once when the EA is first loaded.        |
//+------------------------------------------------------------------+
int OnInit()
  {
   //--- Initialize trading object
   trade.SetExpertMagicNumber(InpMagicNumber);
   trade.SetDeviationInPoints(100); // Allow some slippage
   trade.SetTypeFillingBySymbol(_Symbol);

   //--- Create indicator handle
   ma_handle=iMA(_Symbol,PERIOD_H1,InpMAPeriod,0,InpMAMethod,PRICE_CLOSE);
   if(ma_handle==INVALID_HANDLE)
     {
      Print("Error creating Moving Average indicator. EA will not run.");
      return(INIT_FAILED);
     }
   
   Print("Quantum Bitcoin EA (Grid) Initialized Successfully. Symbol: ", _Symbol, ", Magic Number: ", InpMagicNumber);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//| This is called when the EA is removed or the chart is closed.    |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   //--- Clean up resources
   IndicatorRelease(ma_handle);
   Print("Quantum Bitcoin EA (Grid) Deinitialized. Reason code: ", reason);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//| This function is called on every new price tick.                 |
//+------------------------------------------------------------------+
void OnTick()
  {
   //--- Actions that run on every tick (fast)
   // If any positions are open, check if a trailing stop needs to be adjusted.
   if(PositionsTotalMagic(InpMagicNumber) > 0)
     {
      ManageTrailingStops();
     }
     
   //--- Actions that run only ONCE per new bar (slower, more stable)
   // This prevents the EA from opening multiple trades on the same bar.
   if(!IsNewBar()) return;
   
   //--- Check pre-trade conditions
   if(SymbolInfoInteger(_Symbol,SYMBOL_SPREAD) > InpMaxSpread)
   {
     // Print("Spread is too high: ", SymbolInfoInteger(_Symbol,SYMBOL_SPREAD), " > ", InpMaxSpread);
     return;
   }

   //--- Main logic, executed once per bar
   if(PositionsTotalMagic(InpMagicNumber) > 0)
     {
      // If a grid is already open, manage it and check for closure conditions.
      ManageGrid();
      CheckProfitAndLoss();
     }
   else
     {
      // If no trades are open, look for an opportunity to start a new grid.
      OpenInitialTrade();
     }
  }

//+------------------------------------------------------------------+
//| Checks if a new bar has started on the H1 timeframe.             |
//+------------------------------------------------------------------+
bool IsNewBar()
  {
   static datetime last_bar_time=0;
   datetime current_bar_time=iTime(_Symbol,PERIOD_H1,0);
   if(last_bar_time!=current_bar_time)
     {
      last_bar_time=current_bar_time;
      return(true);
     }
   return(false);
  }

//+------------------------------------------------------------------+
//| Opens the first trade of a new grid based on the trend MA.       |
//+------------------------------------------------------------------+
void OpenInitialTrade()
  {
   // Get the most recent MA value
   double ma_value[1];
   if(CopyBuffer(ma_handle,0,0,1,ma_value)<=0) return;

   MqlTick tick;
   SymbolInfoTick(_Symbol, tick);
   
   // --- Dynamic Lot Size Calculation ---
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   // This formula provides a base lot size. E.g., for 1% risk on a $10,000 account, it calculates ~0.01 lots.
   // The divisor (10000.0) can be adjusted to make the sizing more or less aggressive.
   double calculated_lot = (equity / 10000.0) * (InpInitialRiskPercent / 100.0);
   
   double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double step_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   // Round the calculated lot to the nearest valid lot step
   double initial_lot = round(calculated_lot / step_lot) * step_lot;
   initial_lot = NormalizeDouble(initial_lot, 2);

   // --- Validate Lot Size ---
   // If the calculated lot size is less than the minimum allowed, do not open a trade.
   // This prevents taking on more risk than intended by being forced to use the minimum lot size.
   if(initial_lot < min_lot) 
     {
      Print("Calculated lot size (", DoubleToString(initial_lot, 2), ") is below minimum (", DoubleToString(min_lot, 2), "). No trade opened to avoid unintended risk.");
      return;
     }

   // If the calculated lot size exceeds the maximum, cap it at the maximum allowed.
   if(initial_lot > max_lot)
     {
      Print("Calculated lot size (", DoubleToString(initial_lot, 2), ") exceeds maximum (", DoubleToString(max_lot, 2), "). Capping at max lot size.");
      initial_lot = max_lot;
     }

   // If price is above the MA, it's an uptrend -> Open Buy
   if(tick.ask > ma_value[0])
     {
      trade.Buy(initial_lot, _Symbol, tick.ask, 0, 0, "Initial Buy");
     }
   // If price is below the MA, it's a downtrend -> Open Sell
   else if(tick.bid < ma_value[0])
     {
      trade.Sell(initial_lot, _Symbol, tick.bid, 0, 0, "Initial Sell");
     }
  }

//+------------------------------------------------------------------+
//| Manages an existing grid by adding new trades.                   |
//+------------------------------------------------------------------+
void ManageGrid()
  {
   int position_count = PositionsTotalMagic(InpMagicNumber);
   if(position_count >= InpMaxGridTrades) return; // Stop if max trades reached

   // Get details of the most recently opened position in the grid
   double last_price = GetLastPositionPrice();
   double last_lot = GetLastPositionLot();
   ENUM_POSITION_TYPE last_type = GetLastPositionType();
   
   if(last_price == 0 || last_lot == 0) return;

   MqlTick tick;
   SymbolInfoTick(_Symbol,tick);
   
   // Calculate the lot size for the next trade using the multiplier
   double new_lot = NormalizeDouble(last_lot * InpGridMultiplier, 2);
   
   // Calculate the distance for the next trade, potentially increasing it
   double dynamicGridDistance = InpGridDistance * (1 + (position_count - 1) * (InpGridDistanceMultiplier - 1.0));

   // If the last trade was a BUY, and price has dropped enough, add another Buy
   if(last_type == POSITION_TYPE_BUY && tick.ask < last_price - (dynamicGridDistance * _Point))
     {
      trade.Buy(new_lot, _Symbol, tick.ask, 0, 0, "Grid Buy");
     }
   // If the last trade was a SELL, and price has risen enough, add another Sell
   else if(last_type == POSITION_TYPE_SELL && tick.bid > last_price + (dynamicGridDistance * _Point))
     {
      trade.Sell(new_lot, _Symbol, tick.bid, 0, 0, "Grid Sell");
     }
  }

//+------------------------------------------------------------------+
//| Manages trailing stop loss for all open positions.               |
//+------------------------------------------------------------------+
void ManageTrailingStops()
{
  if(!InpUseTrailingStop) return;

  for(int i = PositionsTotal() - 1; i >= 0; i--)
  {
    if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
    {
      double current_sl = posInfo.StopLoss();
      double open_price = posInfo.PriceOpen();
      double point = _Point;
      MqlTick tick;
      SymbolInfoTick(_Symbol, tick);

      if(posInfo.PositionType() == POSITION_TYPE_BUY)
      {
        // Activate trailing SL only if position is in profit by TrailingStart points
        if(tick.bid > open_price + (InpTrailingStopStart * point))
        {
          double new_sl = tick.bid - (InpTrailingStopDistance * point);
          // Modify SL only if the new SL is higher than the old one
          if(new_sl > open_price && (current_sl == 0 || new_sl > current_sl))
          {
            trade.PositionModify(posInfo.Ticket(), new_sl, posInfo.TakeProfit());
          }
        }
      }
      else if(posInfo.PositionType() == POSITION_TYPE_SELL)
      {
        // Activate trailing SL only if position is in profit by TrailingStart points
        if(tick.ask < open_price - (InpTrailingStopStart * point))
        {
          double new_sl = tick.ask + (InpTrailingStopDistance * point);
          // Modify SL only if the new SL is lower than the old one
          if(new_sl < open_price && (current_sl == 0 || new_sl < current_sl))
          {
            trade.PositionModify(posInfo.Ticket(), new_sl, posInfo.TakeProfit());
          }
        }
      }
    }
  }
}

//+------------------------------------------------------------------+
//| Checks the aggregate profit/loss of the grid and closes if needed.|
//+------------------------------------------------------------------+
void CheckProfitAndLoss()
  {
   double total_profit = 0;
   int position_count = 0;
   
   // Calculate the total floating profit/loss for all grid positions
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
        {
         total_profit += posInfo.Profit() + posInfo.Swap();
         position_count++;
        }
     }

   if(position_count == 0) return;

   // Calculate a dynamic Take Profit that can increase as more trades are opened
   double dynamicTakeProfit = InpTakeProfit * (1 + (position_count - 1) * (InpTakeProfitMultiplier - 1.0));

   // If total profit reaches the target, close all trades
   if(total_profit >= dynamicTakeProfit)
     {
      Print("Take Profit hit. Closing all ", position_count, " positions for $", total_profit);
      CloseAllPositions();
     }

   // Calculate the Stop Loss amount in account currency based on equity percentage
   double stopLossAmount = AccountInfoDouble(ACCOUNT_EQUITY) * (InpStopLoss / 100.0);
   if(total_profit <= -stopLossAmount)
     {
      Print("Stop Loss hit. Closing all ", position_count, " positions for $", total_profit);
      CloseAllPositions();
     }
  }

//+------------------------------------------------------------------+
//| Closes all open positions managed by this EA instance.           |
//+------------------------------------------------------------------+
void CloseAllPositions()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
        {
         trade.PositionClose(posInfo.Ticket());
        }
     }
  }
  
//+------------------------------------------------------------------+
//| UTILITY: Gets the open price of the most recent position.        |
//+------------------------------------------------------------------+
double GetLastPositionPrice()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol && posInfo.Time() > last_time)
      {
         last_time = posInfo.Time();
         last_ticket = posInfo.Ticket();
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket)) return posInfo.PriceOpen();
   return 0;
}

//+------------------------------------------------------------------+
//| UTILITY: Gets the volume (lot size) of the most recent position. |
//+------------------------------------------------------------------+
double GetLastPositionLot()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol && posInfo.Time() > last_time)
      {
         last_time = posInfo.Time();
         last_ticket = posInfo.Ticket();
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket)) return posInfo.Volume();
   return 0;
}

//+------------------------------------------------------------------+
//| UTILITY: Gets the type (Buy/Sell) of the most recent position.   |
//+------------------------------------------------------------------+
ENUM_POSITION_TYPE GetLastPositionType()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol && posInfo.Time() > last_time)
      {
         last_time = posInfo.Time();
         last_ticket = posInfo.Ticket();
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket)) return posInfo.PositionType();
   return (ENUM_POSITION_TYPE)-1;
}

//+------------------------------------------------------------------+
//| UTILITY: Counts total positions for this EA instance.            |
//+------------------------------------------------------------------+
int PositionsTotalMagic(ulong magic)
  {
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == magic && posInfo.Symbol() == _Symbol)
        {
         count++;
        }
     }
   return count;
  }
//+------------------------------------------------------------------+
`;

  return `${header}\n\n${inputs}\n${coreLogic}`;
};

const generateSignalStrategyCode = (config: EAConfig): string => {
    const header = generateHeader('Signal', 'A signal-based EA for BTC/USD H1 using MA, RSI, and ATR. See the NOTICE in the code.');
    const inputs = generateSignalInputs(config);

    const coreLogic = `
#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>

//--- Global Variables & Objects
CTrade         trade;                  // Trade execution object
CPositionInfo  posInfo;                // Position information object
int            ma_handle, atr_handle, rsi_handle; // Handles for indicators

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//| This function is called once when the EA is first loaded.        |
//+------------------------------------------------------------------+
int OnInit()
  {
   //--- Initialize trading object
   trade.SetExpertMagicNumber(InpMagicNumber);
   trade.SetDeviationInPoints(100); // Allow some slippage
   trade.SetTypeFillingBySymbol(_Symbol);

   //--- Create indicator handles
   ma_handle=iMA(_Symbol,PERIOD_H1,InpMAPeriod,0,InpMAMethod,PRICE_CLOSE);
   if(ma_handle==INVALID_HANDLE) { Print("Error creating MA indicator"); return(INIT_FAILED); }
   
   atr_handle=iATR(_Symbol,PERIOD_H1,InpATRPeriod);
   if(atr_handle==INVALID_HANDLE) { Print("Error creating ATR indicator"); return(INIT_FAILED); }
   
   rsi_handle=iRSI(_Symbol,PERIOD_H1,InpRSIPeriod,PRICE_CLOSE);
   if(rsi_handle==INVALID_HANDLE) { Print("Error creating RSI indicator"); return(INIT_FAILED); }
   
   Print("Quantum Bitcoin EA (Signal) Initialized Successfully. Symbol: ", _Symbol, ", Magic Number: ", InpMagicNumber);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//| This is called when the EA is removed or the chart is closed.    |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   //--- Clean up resources
   IndicatorRelease(ma_handle);
   IndicatorRelease(atr_handle);
   IndicatorRelease(rsi_handle);
   Print("Quantum Bitcoin EA (Signal) Deinitialized. Reason code: ", reason);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//| This function is called on every new price tick.                 |
//+------------------------------------------------------------------+
void OnTick()
  {
   //--- Actions that run on every tick (fast)
   // If a position is open, check if the trailing stop needs to be adjusted.
   if(PositionsTotalMagic(InpMagicNumber) > 0)
     {
      ManageTrailingStops();
     }

   //--- Actions that run only ONCE per new bar (slower, more stable)
   // This prevents the EA from executing entry logic multiple times on the same bar.
   if(!IsNewBar()) return;

   //--- Main logic: Only check for new trade signals if no trade is currently open.
   if(PositionsTotalMagic(InpMagicNumber) == 0)
     {
      // Check pre-trade conditions
      if(SymbolInfoInteger(_Symbol,SYMBOL_SPREAD) > InpMaxSpread) return;
      // Look for a valid entry signal
      CheckSignal();
     }
  }

//+------------------------------------------------------------------+
//| Checks if a new bar has started on the H1 timeframe.             |
//+------------------------------------------------------------------+
bool IsNewBar()
  {
   static datetime last_bar_time=0;
   datetime current_bar_time=iTime(_Symbol,PERIOD_H1,0);
   if(last_bar_time!=current_bar_time)
     {
      last_bar_time=current_bar_time;
      return(true);
     }
   return(false);
  }

//+------------------------------------------------------------------+
//| Checks for a trading signal based on MA, RSI, and ATR indicators.|
//+------------------------------------------------------------------+
void CheckSignal()
  {
   // --- 1. Get Indicator Values ---
   // We read data from the most recently closed bar (index 1) to ensure the signal is stable and not repainting.
   double ma_buffer[1], atr_buffer[1], rsi_buffer[1], close_buffer[1];
   if(CopyBuffer(ma_handle, 0, 1, 1, ma_buffer) <= 0 ||
      CopyBuffer(atr_handle, 0, 1, 1, atr_buffer) <= 0 ||
      CopyBuffer(rsi_handle, 0, 1, 1, rsi_buffer) <= 0 ||
      CopyClose(_Symbol, PERIOD_H1, 1, 1, close_buffer) <= 0)
     {
      Print("Error copying indicator buffers. Skipping signal check.");
      return;
     }

   double ma_val = ma_buffer[0];
   double atr_val = atr_buffer[0];
   double rsi_val = rsi_buffer[0];
   double close_val = close_buffer[0];

   // Safety check: ensure ATR is positive to avoid invalid SL/TP levels.
   if(atr_val <= 0)
     {
      Print("ATR value is zero or negative (", atr_val, "). Skipping signal check to prevent invalid SL/TP.");
      return;
     }

   // --- 2. Get Current Market Prices ---
   MqlTick tick;
   SymbolInfoTick(_Symbol, tick);

   // --- 3. Evaluate Trading Signals ---
   // This logic checks for two distinct scenarios: a buy signal or a sell signal.
   // An 'else if' is used to ensure only one signal is acted upon per bar.

   // --- BUY SIGNAL LOGIC ---
   // Condition 1: Trend Filter - Price is in an uptrend (closed above the MA).
   // Condition 2: Entry Trigger - RSI shows a pullback into the oversold area, indicating a potential buying opportunity.
   if(close_val > ma_val && rsi_val < InpRSIOversold)
     {
      // --- Calculate Volatility-Based SL/TP using ATR ---
      // Stop Loss is placed below the entry price by a multiple of the ATR.
      // Take Profit is placed above the entry price by a multiple of the ATR.
      // This makes risk management dynamic and adaptive to market volatility.
      double stop_loss = tick.ask - (atr_val * InpATRMultiplierSL);
      double take_profit = tick.ask + (atr_val * InpATRMultiplierTP);

      // Execute the buy trade using the configured fixed lot size.
      trade.Buy(InpLotSize, _Symbol, tick.ask, stop_loss, take_profit, "Buy Signal (MA/RSI)");
     }
   // --- SELL SIGNAL LOGIC ---
   // Condition 1: Trend Filter - Price is in a downtrend (closed below the MA).
   // Condition 2: Entry Trigger - RSI shows a rally into the overbought area, indicating a potential selling opportunity.
   else if(close_val < ma_val && rsi_val > InpRSIOverbought)
     {
      // --- Calculate Volatility-Based SL/TP using ATR ---
      // Stop Loss is placed above the entry price by a multiple of the ATR.
      // Take Profit is placed below the entry price by a multiple of the ATR.
      double stop_loss = tick.bid + (atr_val * InpATRMultiplierSL);
      double take_profit = tick.bid - (atr_val * InpATRMultiplierTP);

      // Execute the sell trade using the configured fixed lot size.
      trade.Sell(InpLotSize, _Symbol, tick.bid, stop_loss, take_profit, "Sell Signal (MA/RSI)");
     }
  }

//+------------------------------------------------------------------+
//| Manages trailing stop loss for the open position.                |
//+------------------------------------------------------------------+
void ManageTrailingStops()
{
  if(!InpUseTrailingStop) return;

  // Since this strategy only allows one position, we can simplify the loop
  if(posInfo.SelectByIndex(0) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
  {
      double current_sl = posInfo.StopLoss();
      double open_price = posInfo.PriceOpen();
      double point = _Point;
      MqlTick tick;
      SymbolInfoTick(_Symbol, tick);

      if(posInfo.PositionType() == POSITION_TYPE_BUY)
      {
        // Activate trailing SL only if position is in profit by TrailingStart points
        if(tick.bid > open_price + (InpTrailingStopStart * point))
        {
          double new_sl = tick.bid - (InpTrailingStopDistance * point);
          // Modify SL only if the new SL is higher than the old one
          if(new_sl > open_price && (current_sl == 0 || new_sl > current_sl))
          {
            trade.PositionModify(posInfo.Ticket(), new_sl, posInfo.TakeProfit());
          }
        }
      }
      else if(posInfo.PositionType() == POSITION_TYPE_SELL)
      {
        // Activate trailing SL only if position is in profit by TrailingStart points
        if(tick.ask < open_price - (InpTrailingStopStart * point))
        {
          double new_sl = tick.ask + (InpTrailingStopDistance * point);
          // Modify SL only if the new SL is lower than the old one
          if(new_sl < open_price && (current_sl == 0 || new_sl < current_sl))
          {
            trade.PositionModify(posInfo.Ticket(), new_sl, posInfo.TakeProfit());
          }
        }
      }
  }
}

//+------------------------------------------------------------------+
//| UTILITY: Counts total positions for this EA instance.            |
//+------------------------------------------------------------------+
int PositionsTotalMagic(ulong magic)
  {
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == magic && posInfo.Symbol() == _Symbol)
        {
         count++;
        }
     }
   return count;
  }
//+------------------------------------------------------------------+
`;
    return `${header}\n\n${inputs}\n${coreLogic}`;
};

export const generateMql5Code = (config: EAConfig): string => {
    if (config.strategyType === 'signal') {
        return generateSignalStrategyCode(config);
    }
    return generateGridStrategyCode(config);
};