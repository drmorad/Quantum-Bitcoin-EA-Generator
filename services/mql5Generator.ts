
import type { EAConfig } from '../types';

export const generateMql5Code = (config: EAConfig): string => {
  return `
//+------------------------------------------------------------------+
//|                                       Quantum_Bitcoin_EA.mq5 |
//|                      Generated by React MQL5 Code Generator      |
//|      This EA should be backtested thoroughly before live use.    |
//+------------------------------------------------------------------+
#property copyright "Generated Code"
#property link      "https://github.com/your-repo"
#property version   "1.00"
#property description "A trend-following grid EA for BTCUSD H1, based on the Quantum Bitcoin EA concept."

#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>

//--- EA Inputs
input ulong  InpMagicNumber    = ${config.magicNumber};    // Magic Number
input double InpInitialLot     = ${config.initialLot.toFixed(2)};    // Initial Lot Size
input int    InpMaxSpread      = ${config.maxSpread};      // Max Spread in Points
input int    InpGridDistance   = ${config.gridDistance};   // Min distance between grid trades in Points
input double InpGridMultiplier = ${config.gridMultiplier.toFixed(2)};    // Lot size multiplier for grid
input int    InpMaxGridTrades  = ${config.maxGridTrades};      // Max number of grid trades
input int    InpMAPeriod       = ${config.maPeriod};       // Moving Average Period for Trend
input double InpTakeProfit     = ${config.takeProfit.toFixed(2)};    // Take Profit in deposit currency
input double InpStopLoss       = ${config.stopLoss.toFixed(2)};      // Stop Loss in deposit currency

//--- Global Variables
CTrade         trade;
CPositionInfo  posInfo;
int            ma_handle;
datetime       lastTradeTime;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   //--- Initialize trade object
   trade.SetExpertMagicNumber(InpMagicNumber);
   trade.SetDeviationInPoints(100); // Slippage
   trade.SetTypeFillingBySymbol(_Symbol);

   //--- Create Moving Average indicator handle
   ma_handle=iMA(_Symbol,PERIOD_H1,InpMAPeriod,0,MODE_SMA,PRICE_CLOSE);
   if(ma_handle==INVALID_HANDLE)
     {
      Print("Error creating MA indicator");
      return(INIT_FAILED);
     }
     
   lastTradeTime = 0;
   
   Print("Quantum Bitcoin EA Initialized. Symbol: ", _Symbol);
   Print("Magic Number: ", InpMagicNumber);
   
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   IndicatorRelease(ma_handle);
   Print("Quantum Bitcoin EA Deinitialized. Reason: ", reason);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   //--- Prevent trading on every tick, only on new H1 bar
   if(!IsNewBar())
      return;

   //--- Check for max spread
   if(SymbolInfoInteger(_Symbol,SYMBOL_SPREAD) > InpMaxSpread)
     {
      // Comment("Spread is too high: ", (string)SymbolInfoInteger(_Symbol,SYMBOL_SPREAD));
      return;
     }

   //--- Manage existing positions
   if(PositionsTotalMagic(InpMagicNumber) > 0)
     {
      ManageGrid();
      CheckProfitAndLoss();
     }
   //--- Open initial position if none exist
   else
     {
      OpenInitialTrade();
     }
  }

//+------------------------------------------------------------------+
//| Check if a new H1 bar has opened                                 |
//+------------------------------------------------------------------+
bool IsNewBar()
  {
   static datetime last_bar_time=0;
   datetime current_bar_time=iTime(_Symbol,PERIOD_H1,0);
   if(last_bar_time!=current_bar_time)
     {
      last_bar_time=current_bar_time;
      return(true);
     }
   return(false);
  }

//+------------------------------------------------------------------+
//| Opens the first trade in a series                                |
//+------------------------------------------------------------------+
void OpenInitialTrade()
  {
   double ma_value[1];
   if(CopyBuffer(ma_handle,0,0,1,ma_value)<=0)
     {
      Print("Error copying MA buffer");
      return;
     }

   MqlTick tick;
   SymbolInfoTick(_Symbol, tick);

   //--- Trend Following Logic
   //--- Buy condition
   if(tick.ask > ma_value[0])
     {
      trade.Buy(InpInitialLot, _Symbol, tick.ask, 0, 0, "Initial Buy");
     }
   //--- Sell condition
   else if(tick.bid < ma_value[0])
     {
      trade.Sell(InpInitialLot, _Symbol, tick.bid, 0, 0, "Initial Sell");
     }
  }

//+------------------------------------------------------------------+
//| Manages the grid by adding trades if conditions are met          |
//+------------------------------------------------------------------+
void ManageGrid()
  {
   if(PositionsTotalMagic(InpMagicNumber) >= InpMaxGridTrades)
      return;

   double last_price = GetLastPositionPrice();
   double last_lot = GetLastPositionLot();
   ENUM_POSITION_TYPE last_type = GetLastPositionType();
   
   if(last_price == 0 || last_lot == 0) return;

   MqlTick tick;
   SymbolInfoTick(_Symbol,tick);
   
   double new_lot = NormalizeDouble(last_lot * InpGridMultiplier, 2);

   //--- Manage Buy Grid
   if(last_type == POSITION_TYPE_BUY)
     {
      if(tick.ask < last_price - (InpGridDistance * _Point))
        {
         trade.Buy(new_lot, _Symbol, tick.ask, 0, 0, "Grid Buy");
        }
     }
   //--- Manage Sell Grid
   else if(last_type == POSITION_TYPE_SELL)
     {
      if(tick.bid > last_price + (InpGridDistance * _Point))
        {
         trade.Sell(new_lot, _Symbol, tick.bid, 0, 0, "Grid Sell");
        }
     }
  }

//+------------------------------------------------------------------+
//| Checks total profit/loss and closes all positions if target hit  |
//+------------------------------------------------------------------+
void CheckProfitAndLoss()
  {
   double total_profit = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
        {
         total_profit += posInfo.Profit() + posInfo.Swap();
        }
     }

   //--- Take Profit
   if(total_profit >= InpTakeProfit)
     {
      Print("Take Profit hit. Total profit: ", DoubleToString(total_profit, 2));
      CloseAllPositions();
     }

   //--- Stop Loss
   if(total_profit <= -InpStopLoss)
     {
      Print("Stop Loss hit. Total loss: ", DoubleToString(total_profit, 2));
      CloseAllPositions();
     }
  }

//+------------------------------------------------------------------+
//| Closes all open positions managed by this EA                     |
//+------------------------------------------------------------------+
void CloseAllPositions()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
        {
         trade.PositionClose(posInfo.Ticket());
        }
     }
  }
  
//+------------------------------------------------------------------+
//| Get details of the last opened position                          |
//+------------------------------------------------------------------+
double GetLastPositionPrice()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol)
      {
         if(posInfo.Time() > last_time)
         {
            last_time = posInfo.Time();
            last_ticket = posInfo.Ticket();
         }
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket))
      return posInfo.PriceOpen();
      
   return 0;
}

double GetLastPositionLot()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol)
      {
         if(posInfo.Time() > last_time)
         {
            last_time = posInfo.Time();
            last_ticket = posInfo.Ticket();
         }
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket))
      return posInfo.Volume();
      
   return 0;
}

ENUM_POSITION_TYPE GetLastPositionType()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol)
      {
         if(posInfo.Time() > last_time)
         {
            last_time = posInfo.Time();
            last_ticket = posInfo.Ticket();
         }
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket))
      return posInfo.PositionType();
      
   return (ENUM_POSITION_TYPE)-1;
}

//+------------------------------------------------------------------+
//| Counts positions managed by this EA                              |
//+------------------------------------------------------------------+
int PositionsTotalMagic(ulong magic)
  {
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == magic && posInfo.Symbol() == _Symbol)
        {
         count++;
        }
     }
   return count;
  }
//+------------------------------------------------------------------+
`;
};
