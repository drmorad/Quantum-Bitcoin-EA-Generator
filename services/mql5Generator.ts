import type { EAConfig } from '../types';

const generateGridStrategyCode = (config: EAConfig): string => {
  const maMethod = config.maType === 'SMA' ? 'MODE_SMA' : 'MODE_EMA';

  return `
//+------------------------------------------------------------------+
//|                                       Quantum_Bitcoin_EA.mq5 |
//|                      Generated by React MQL5 Code Generator      |
//|               Strategy: Grid - Backtest Thoroughly               |
//+------------------------------------------------------------------+
#property copyright "Generated Code"
#property link      "https://github.com/your-repo"
#property version   "1.00"
#property description "A trend-following grid EA for BTCUSD H1."

#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>

//--- EA Inputs
input ulong  InpMagicNumber    = ${config.magicNumber};    // Magic Number
input double InpInitialLot     = ${config.initialLot};    // Initial Lot Size
input int    InpMaxSpread      = ${config.maxSpread};      // Max Spread in Points
input int    InpGridDistance   = ${config.gridDistance};   // Min distance between grid trades in Points
input double InpGridDistanceMultiplier = ${config.gridDistanceMultiplier.toFixed(2)}; // Grid Distance Multiplier
input double InpGridMultiplier = ${config.gridMultiplier.toFixed(2)};    // Lot size multiplier for grid
input int    InpMaxGridTrades  = ${config.maxGridTrades};      // Max number of grid trades
input ENUM_MA_METHOD InpMAMethod = ${maMethod};  // Moving Average Method
input int    InpMAPeriod       = ${config.maPeriod};       // Moving Average Period for Trend
input double InpTakeProfit     = ${config.takeProfit.toFixed(2)};    // Take Profit in deposit currency
input double InpTakeProfitMultiplier = ${config.takeProfitMultiplier.toFixed(2)}; // Take Profit Multiplier per grid trade
input double InpStopLoss       = ${config.stopLoss.toFixed(2)};      // Stop Loss in % of Account Equity
input bool   InpUseTrailingStop = ${config.useTrailingStop ? 'true' : 'false'}; // Enable/Disable Trailing Stop
input int    InpTrailingStopStart = ${config.trailingStopStart}; // Points in profit to start trailing
input int    InpTrailingStopDistance = ${config.trailingStopDistance}; // Distance to trail behind price in points

//--- Global Variables
CTrade         trade;
CPositionInfo  posInfo;
int            ma_handle;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   trade.SetExpertMagicNumber(InpMagicNumber);
   trade.SetDeviationInPoints(100);
   trade.SetTypeFillingBySymbol(_Symbol);

   ma_handle=iMA(_Symbol,PERIOD_H1,InpMAPeriod,0,InpMAMethod,PRICE_CLOSE);
   if(ma_handle==INVALID_HANDLE)
     {
      Print("Error creating MA indicator");
      return(INIT_FAILED);
     }
   
   Print("Quantum Bitcoin EA (Grid) Initialized. Symbol: ", _Symbol);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   IndicatorRelease(ma_handle);
   Print("Quantum Bitcoin EA (Grid) Deinitialized. Reason: ", reason);
  }

//+------------------------------------------------------------------+
void OnTick()
  {
   if(PositionsTotalMagic(InpMagicNumber) > 0)
     {
      ManageTrailingStops();
     }
     
   if(!IsNewBar()) return;
   if(SymbolInfoInteger(_Symbol,SYMBOL_SPREAD) > InpMaxSpread) return;

   if(PositionsTotalMagic(InpMagicNumber) > 0)
     {
      ManageGrid();
      CheckProfitAndLoss();
     }
   else
     {
      OpenInitialTrade();
     }
  }

//+------------------------------------------------------------------+
bool IsNewBar()
  {
   static datetime last_bar_time=0;
   datetime current_bar_time=iTime(_Symbol,PERIOD_H1,0);
   if(last_bar_time!=current_bar_time)
     {
      last_bar_time=current_bar_time;
      return(true);
     }
   return(false);
  }

//+------------------------------------------------------------------+
void OpenInitialTrade()
  {
   //--- Get MA value from the last completed bar for a stable signal
   double ma_value[1];
   if(CopyBuffer(ma_handle,0,1,1,ma_value)<=0)
     {
      Print("Could not copy MA buffer, not enough data?");
      return;
     }

   MqlTick tick;
   SymbolInfoTick(_Symbol, tick);

   //--- Trend condition: Is the current price above/below the MA of the last completed bar?
   if(tick.ask > ma_value[0])
     {
      trade.Buy(InpInitialLot, _Symbol, tick.ask, 0, 0, "Initial Buy");
     }
   else if(tick.bid < ma_value[0])
     {
      trade.Sell(InpInitialLot, _Symbol, tick.bid, 0, 0, "Initial Sell");
     }
  }

//+------------------------------------------------------------------+
void ManageGrid()
  {
   int position_count = PositionsTotalMagic(InpMagicNumber);
   if(position_count >= InpMaxGridTrades) return;

   double last_price = GetLastPositionPrice();
   double last_lot = GetLastPositionLot();
   ENUM_POSITION_TYPE last_type = GetLastPositionType();
   
   if(last_price == 0 || last_lot == 0) return;

   MqlTick tick;
   SymbolInfoTick(_Symbol,tick);
   
   double new_lot = NormalizeDouble(last_lot * InpGridMultiplier, 2);
   
   double dynamicGridDistance = InpGridDistance * (1 + (position_count - 1) * (InpGridDistanceMultiplier - 1.0));

   if(last_type == POSITION_TYPE_BUY && tick.ask < last_price - (dynamicGridDistance * _Point))
     {
      trade.Buy(new_lot, _Symbol, tick.ask, 0, 0, "Grid Buy");
     }
   else if(last_type == POSITION_TYPE_SELL && tick.bid > last_price + (dynamicGridDistance * _Point))
     {
      trade.Sell(new_lot, _Symbol, tick.bid, 0, 0, "Grid Sell");
     }
  }

//+------------------------------------------------------------------+
void ManageTrailingStops()
{
  if(!InpUseTrailingStop) return;

  for(int i = PositionsTotal() - 1; i >= 0; i--)
  {
    if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
    {
      double current_sl = posInfo.StopLoss();
      double open_price = posInfo.PriceOpen();
      double point = _Point;
      MqlTick tick;
      SymbolInfoTick(_Symbol, tick);

      if(posInfo.PositionType() == POSITION_TYPE_BUY)
      {
        if(tick.bid > open_price + (InpTrailingStopStart * point))
        {
          double new_sl = tick.bid - (InpTrailingStopDistance * point);
          if(new_sl > open_price && (current_sl == 0 || new_sl > current_sl))
          {
            trade.PositionModify(posInfo.Ticket(), new_sl, posInfo.TakeProfit());
          }
        }
      }
      else if(posInfo.PositionType() == POSITION_TYPE_SELL)
      {
        if(tick.ask < open_price - (InpTrailingStopStart * point))
        {
          double new_sl = tick.ask + (InpTrailingStopDistance * point);
          if(new_sl < open_price && (current_sl == 0 || new_sl < current_sl))
          {
            trade.PositionModify(posInfo.Ticket(), new_sl, posInfo.TakeProfit());
          }
        }
      }
    }
  }
}

//+------------------------------------------------------------------+
void CheckProfitAndLoss()
  {
   double total_profit = 0;
   int position_count = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
        {
         total_profit += posInfo.Profit() + posInfo.Swap();
         position_count++;
        }
     }

   if(position_count == 0) return;

   double dynamicTakeProfit = InpTakeProfit * (1 + (position_count - 1) * (InpTakeProfitMultiplier - 1.0));

   if(total_profit >= dynamicTakeProfit)
     {
      CloseAllPositions();
     }

   double stopLossAmount = AccountInfoDouble(ACCOUNT_EQUITY) * (InpStopLoss / 100.0);
   if(total_profit <= -stopLossAmount)
     {
      CloseAllPositions();
     }
  }

//+------------------------------------------------------------------+
void CloseAllPositions()
  {
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == InpMagicNumber && posInfo.Symbol() == _Symbol)
        {
         trade.PositionClose(posInfo.Ticket());
        }
     }
  }
  
//+------------------------------------------------------------------+
double GetLastPositionPrice()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol && posInfo.Time() > last_time)
      {
         last_time = posInfo.Time();
         last_ticket = posInfo.Ticket();
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket)) return posInfo.PriceOpen();
   return 0;
}

double GetLastPositionLot()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol && posInfo.Time() > last_time)
      {
         last_time = posInfo.Time();
         last_ticket = posInfo.Ticket();
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket)) return posInfo.Volume();
   return 0;
}

ENUM_POSITION_TYPE GetLastPositionType()
{
   ulong last_ticket=0;
   datetime last_time=0;
   
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      if(posInfo.SelectByIndex(i) && posInfo.Magic()==InpMagicNumber && posInfo.Symbol()==_Symbol && posInfo.Time() > last_time)
      {
         last_time = posInfo.Time();
         last_ticket = posInfo.Ticket();
      }
   }
   
   if(posInfo.SelectByTicket(last_ticket)) return posInfo.PositionType();
   return (ENUM_POSITION_TYPE)-1;
}

//+------------------------------------------------------------------+
int PositionsTotalMagic(ulong magic)
  {
   int count = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
     {
      if(posInfo.SelectByIndex(i) && posInfo.Magic() == magic && posInfo.Symbol() == _Symbol)
        {
         count++;
        }
     }
   return count;
  }
//+------------------------------------------------------------------+
`;
};

const generateSignalStrategyCode = (config: EAConfig): string => {
    const maMethod = config.signal_maType === 'SMA' ? 'MODE_SMA' : 'MODE_EMA';

    return `
//+------------------------------------------------------------------+
//|                                       Quantum_Bitcoin_EA.mq5 |
//|                      Generated by React MQL5 Code Generator      |
//|             Strategy: Signal - Backtest Thoroughly               |
//+------------------------------------------------------------------+
#property copyright "Generated Code"
#property link      "https://github.com/your-repo"
#property version   "1.00"
#property description "A signal-based EA for BTCUSD H1 using MA, RSI, and ATR."

#include <Trade/Trade.mqh>

//--- EA Inputs
input ulong  InpMagicNumber    = ${config.magicNumber};    // Magic Number
input int    InpMaxSpread      = ${config.maxSpread};      // Max Spread in Points
input double InpLotSize        = ${config.signal_lotSize};      // Fixed Lot Size

//--- Indicator Inputs
input ENUM_MA_METHOD InpMAMethod = ${maMethod};  // Moving Average Method
input int    InpMAPeriod       = ${config.signal_maPeriod};       // MA Period for Trend Filter
input int    InpATRPeriod      = ${config.signal_atrPeriod};      // ATR Period for Volatility
input double InpATRMultiplierSL= ${config.signal_atrMultiplierSL.toFixed(2)}; // ATR Multiplier for Stop Loss
input double InpATRMultiplierTP= ${config.signal_atrMultiplierTP.toFixed(2)}; // ATR Multiplier for Take Profit
input int    InpRSIPeriod      = ${config.signal_rsiPeriod};      // RSI Period
input double InpBSIOversold   = ${config.signal_rsiOversold};    // RSI Oversold Level for Buys
input double InpBSIOverbought  = ${config.signal_rsiOverbought};  // RSI Overbought Level for Sells

//--- Global Variables
CTrade         trade;
int            ma_handle;
int            atr_handle;
int            rsi_handle;

//+------------------------------------------------------------------+
int OnInit()
  {
   trade.SetExpertMagicNumber(InpMagicNumber);
   trade.SetDeviationInPoints(100);
   trade.SetTypeFillingBySymbol(_Symbol);

   ma_handle=iMA(_Symbol,PERIOD_H1,InpMAPeriod,0,InpMAMethod,PRICE_CLOSE);
   if(ma_handle==INVALID_HANDLE) { Print("Error creating MA indicator"); return(INIT_FAILED); }
   
   atr_handle=iATR(_Symbol,PERIOD_H1,InpATRPeriod);
   if(atr_handle==INVALID_HANDLE) { Print("Error creating ATR indicator"); return(INIT_FAILED); }
   
   rsi_handle=iRSI(_Symbol,PERIOD_H1,InpRSIPeriod,PRICE_CLOSE);
   if(rsi_handle==INVALID_HANDLE) { Print("Error creating RSI indicator"); return(INIT_FAILED); }
   
   Print("Quantum Bitcoin EA (Signal) Initialized. Symbol: ", _Symbol);
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   IndicatorRelease(ma_handle);
   IndicatorRelease(atr_handle);
   IndicatorRelease(rsi_handle);
   Print("Quantum Bitcoin EA (Signal) Deinitialized. Reason: ", reason);
  }

//+------------------------------------------------------------------+
void OnTick()
  {
   if(!IsNewBar()) return;
   
   //--- Only trade if no positions are currently open
   if(PositionsTotal() > 0) return;
   
   //--- Check spread condition
   if(SymbolInfoInteger(_Symbol,SYMBOL_SPREAD) > InpMaxSpread) return;
   
   //--- Check for trading signals
   CheckSignal();
  }

//+------------------------------------------------------------------+
bool IsNewBar()
  {
   static datetime last_bar_time=0;
   datetime current_bar_time=iTime(_Symbol,PERIOD_H1,0);
   if(last_bar_time!=current_bar_time)
     {
      last_bar_time=current_bar_time;
      return(true);
     }
   return(false);
  }

//+------------------------------------------------------------------+
void CheckSignal()
  {
   //--- Get indicator values (we need values for the completed bar, so shift is 1)
   double ma_buffer[1], atr_buffer[1], rsi_buffer[1], close_buffer[1];
   if(CopyBuffer(ma_handle, 0, 1, 1, ma_buffer) <= 0 ||
      CopyBuffer(atr_handle, 0, 1, 1, atr_buffer) <= 0 ||
      CopyBuffer(rsi_handle, 0, 1, 1, rsi_buffer) <= 0 ||
      CopyClose(_Symbol, PERIOD_H1, 1, 1, close_buffer) <= 0)
     {
      Print("Error copying indicator buffers.");
      return;
     }
     
   double ma_val = ma_buffer[0];
   double atr_val = atr_buffer[0];
   double rsi_val = rsi_buffer[0];
   double close_val = close_buffer[0];
   
   MqlTick tick;
   SymbolInfoTick(_Symbol, tick);

   //--- BUY SIGNAL: Price is above MA (uptrend) and RSI is oversold
   if(close_val > ma_val && rsi_val < InpBSIOversold)
     {
      double stop_loss = tick.ask - (atr_val * InpATRMultiplierSL);
      double take_profit = tick.ask + (atr_val * InpATRMultiplierTP);
      trade.Buy(InpLotSize, _Symbol, tick.ask, stop_loss, take_profit, "Buy Signal");
      return; // Exit after placing trade
     }

   //--- SELL SIGNAL: Price is below MA (downtrend) and RSI is overbought
   if(close_val < ma_val && rsi_val > InpBSIOverbought)
     {
      double stop_loss = tick.bid + (atr_val * InpATRMultiplierSL);
      double take_profit = tick.bid - (atr_val * InpATRMultiplierTP);
      trade.Sell(InpLotSize, _Symbol, tick.bid, stop_loss, take_profit, "Sell Signal");
      return; // Exit after placing trade
     }
  }
//+------------------------------------------------------------------+
`;
};

export const generateMql5Code = (config: EAConfig): string => {
    if (config.strategyType === 'signal') {
        return generateSignalStrategyCode(config);
    }
    return generateGridStrategyCode(config);
};
